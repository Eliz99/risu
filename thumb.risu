###############################################################################
# Copyright (c) 2010 Linaro Limited
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     Peter Maydell (Linaro) - initial implementation
###############################################################################

# Input file for risugen defining Thumb instructions

.mode thumb

# The format here is:
# insnname encodingname bitfield ...
# (and we'll have a trailing bit for specifying constraints later)
# where each bitfield is either:
#  var:sz  specifying a variable field of size sz (sz == 0 if :sz omitted)
#  [01]*   specifying fixed bits
# Field names beginning 'r' are special as they are assumed to be general
# purpose registers. They get an automatic "cannot be 13 or 15" (sp/pc)
# constraint.
# The optional eval-block at the end of the line (which must be
# enclosed in braces) is a perl statement to be evaluated and which
# must return true if the generated statement is OK, false if the
# generator should retry with a fresh random number. It is evaluated
# in a context where variables with the same names as the defined
# variable fields are initialised. The intention is that odd cases
# where you need to apply some sort of constraint to the generated
# instruction can be handled via this mechanism.
# NB that there is no sanity checking that you don't do bad things
# in the eval block, although there is a basic check for syntax
# errors and and we bail out if the constraint returns failure too often.

#ADD T1 000 1100 rm:3 rn:3 rd:3
#ADD T3 11101 01 1000 s rn:4 0 imma:3 rd:4 immb:2 type:2 rm:4

#QDADD T1 11111 010 1000 rn:4 1111 rd:4 1001 rm:4
#QADD T1 11111 010 1000 rn:4 1111 rd:4 1000 rm:4
#QDSUB T1 11111 010 1000 rn:4 1111 rd:4 1011 rm:4
#QSUB T1 11111 010 1000 rn:4 1111 rd:4 1010 rm:4

PKH T1 11101 01 0110 0 rn:4 0 imma:3 rd:4 immb:2 tb 0 rm:4

# 32x32->64 but result is high word only
SMMLA T1 11111 0110 101 rn:4 ra:4 rd:4 000 r rm:4
SMMLS T1 11111 0110 110 rn:4 ra:4 rd:4 000 r rm:4
# Note that this doesn't overlap with SMMLA because of the implicit
# constraints on registers fields (ie not 13 or 15)
SMMUL T1 11111 0110 101 rn:4 1111 rd:4 000 r rm:4

# preload and memory hint space (in the byte and halfword
# load space, where Rt == 15).
# The constraint is to avoid UNPREDICTABLE space
HINTSPACE T1 111 1100 op1:2 0 z 1 y:4 1111 op2:6 any:6 { ($y == 15) || (($op1 & 1) != 0) || !((($op2 & 0x24) == 0x24) || (($op2 & 0x3c) == 0x38)) ; }

# VMLAL, VMLSL, VQDMLAL, VQDMLSL, VMULL, VQDMULL
# NB that enc T1 is actually VMLA/VMLS only, T2 is VMLAL/VMLSL only
VMLAL T2 111 u 1111 1 d sz:2 vn:4 vd:3 0 10 op 0 n 0 m 0 vm:4 { $sz != 3; }
# VQDMLAL and VQDMLSL (not scalar form)
VQDLAL T1 1110 1111 1 d sz:2 vn:4 vd:3 0 10 op 1 n 0 m 0 vm:4 { ($sz != 3) && ($sz != 0); }
# VMULL (excludes the polynomial case!)
VMULL T2 111 u 1111 1 d sz:2 vn:4 vd:3 0 11 0 0 n 0 m 0 vm:4 { ($sz != 3) && ($sz != 0); }
# VQDMULL (not scalar form)
VQDMULL T1 1110 1111 1 d sz:2 vn:4 vd:3 0 1101 n 0 m 0 vm:4 { ($sz != 3) && ($sz != 0); }
