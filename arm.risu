###############################################################################
# Copyright (c) 2010 Linaro Limited
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     Peter Maydell (Linaro) - initial implementation
###############################################################################

# Input file for risugen defining ARM instructions

# The format here is:
# insnname encodingname bitfield ...
# (and we'll have a trailing bit for specifying constraints later)
# where each bitfield is either:
#  var:sz  specifying a variable field of size sz (sz == 0 if :sz omitted)
#  [01]*   specifying fixed bits
# Field names beginning 'r' are special as they are assumed to be general
# purpose registers. They get an automatic "cannot be 13 or 15" (sp/pc)
# constraint.

# Some random patterns
#ADD A1 cond:4 0000 100 s rn:4 rd:4 imm:5 type:2 0 rm:4
#RBIT A1 cond:4 0110 1111 1111 rd:4 1111 0011 rm:4
#VADD A2 cond:4 11100 d 11 vn:4 vd:4 101 sz n 0 m 0 vm:4


########### VCVT #########################################
# These patterns should cover all the VCVT* instructions
# in their ARM encodings. NB that the patterns for half
# precision conversions are commented out and untested.
##########################################################

# VCVT between fp and int: split in two because opc2 must be 000 or 10x (A8.6.295)
VCVT_a A1 cond:4 11101 d 111 000 vd:4 101 sz op 1 m 0 vm:4
VCVT_b A1 cond:4 11101 d 111 10 x vd:4 101 sz op 1 m 0 vm:4

# VCVT between fp and fixed point (A.8.6.297)
# Ugh. UNPREDICTABLE unless the 32 bit int formed by imm4:i is at least
# 16 (if sx is 0) or 32 (if sx is 1). That is, if sx==0 then either
# bit 3 must be 0 or bits 2..0 and 5 must be 0.
# sx==1 case first:
VCVT_c A1 cond:4 11101 d 111 op 1 u vd:4 101 sf 1 1 i 0 imm:4
# sx==0, bit 3 == 0
VCVT_d A1 cond:4 11101 d 111 op 1 u vd:4 101 sf 0 1 i 0 0 imm:3
# sx==0, bit 3 == 1, bits 2..0 and 5 0
VCVT_e A1 cond:4 11101 d 111 op 1 u vd:4 101 sf 0 1 0 0 1000

# VCVT fp to integer, neon (A8.6.294)
# Split to not generate the Q=1 Vd<0> or Vm<0>=1 cases
# (they UNDEF but qemu gets this wrong for just about all neon)
VCVT_neon_q0 A1 1111 0011 1 d 11 10 11 vd:4 0 11 op:2 0 m 0 vm:4
VCVT_neon_q1 A1 1111 0011 1 d 11 10 11 vd:3 0 0 11 op:2 1 m 0 vm:3 0

# VCVT fp to fixed, neon (A8.6.296)
# split to avoid generating undef case for Q=1, Vd<0> or Vm<0>=1
VCVT_neon_b_q0 A1 1111 001 u 1 d 1 imm:5 vd:4 111 op 0 0 m 1 vm:4
VCVT_neon_b_q1 A1 1111 001 u 1 d 1 imm:5 vd:3 0 111 op 0 1 m 1 vm:3 0

# VCVT between double and single (A8.6.298)
VCVT_298 A1 cond:4 1110 1 d 11 0111 vd:4 101 sz 1 1 m 0 vm:4

# These three patterns deal with conversions to and from
# half-precision (16 bit) floats. A8 doesn't have these so
# the patterns are untested.

# we don't generate the sz!=01 UNDEF cases
# two patterns to avoid the op==1 Vd<0>==1 and op==0 Vm<0>==1 UNDEF cases
# VCVT_299_a A1 1111 0011 1 d 11 01 10 vd:4 011 0 0 0 m 0 vm:3 0
# VCVT_299_b A1 1111 0011 1 d 11 01 10 vd:3 0 011 1 0 0 m 0 vm:4
# VCVTB, VCVTT (A8.6.300)
# VCTV_B_TT A1 cond:4 1110 1 d 11 001 op vd:4 101 0 t 1 m 0 vm:4


